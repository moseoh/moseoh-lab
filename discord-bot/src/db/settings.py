# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.30.0
# source: settings.sql
import dataclasses
from typing import AsyncIterator, Iterator, Optional

import sqlalchemy
import sqlalchemy.ext.asyncio

from src.db import models


DELETE_ALARM_SETTING = """-- name: delete_alarm_setting \\:exec
DELETE FROM alarm_settings
WHERE guild_id = :p1 AND alarm_type = :p2
"""


DELETE_ALARM_SETTINGS_BY_CHANNEL = """-- name: delete_alarm_settings_by_channel \\:exec
DELETE FROM alarm_settings
WHERE channel_id = :p1
"""


GET_ALARM_SETTING = """-- name: get_alarm_setting \\:one
SELECT guild_id, alarm_type, channel_id, created_at, updated_at
FROM alarm_settings
WHERE guild_id = :p1 AND alarm_type = :p2
LIMIT 1
"""


GET_ALARM_SETTINGS_BY_TYPE = """-- name: get_alarm_settings_by_type \\:many
SELECT guild_id, channel_id
FROM alarm_settings
WHERE alarm_type = :p1
"""


@dataclasses.dataclass()
class GetAlarmSettingsByTypeRow:
    guild_id: str
    channel_id: str


UPSERT_ALARM_SETTING = """-- name: upsert_alarm_setting \\:one
INSERT INTO alarm_settings (guild_id, alarm_type, channel_id)
VALUES (:p1, :p2, :p3)
ON CONFLICT (guild_id, alarm_type) DO UPDATE SET
    channel_id = EXCLUDED.channel_id,
    updated_at = CURRENT_TIMESTAMP
RETURNING guild_id, alarm_type, channel_id, created_at, updated_at
"""


class Querier:
    def __init__(self, conn: sqlalchemy.engine.Connection):
        self._conn = conn

    def delete_alarm_setting(self, *, guild_id: str, alarm_type: str) -> None:
        self._conn.execute(sqlalchemy.text(DELETE_ALARM_SETTING), {"p1": guild_id, "p2": alarm_type})

    def delete_alarm_settings_by_channel(self, *, channel_id: str) -> None:
        self._conn.execute(sqlalchemy.text(DELETE_ALARM_SETTINGS_BY_CHANNEL), {"p1": channel_id})

    def get_alarm_setting(self, *, guild_id: str, alarm_type: str) -> Optional[models.AlarmSetting]:
        row = self._conn.execute(sqlalchemy.text(GET_ALARM_SETTING), {"p1": guild_id, "p2": alarm_type}).first()
        if row is None:
            return None
        return models.AlarmSetting(
            guild_id=row[0],
            alarm_type=row[1],
            channel_id=row[2],
            created_at=row[3],
            updated_at=row[4],
        )

    def get_alarm_settings_by_type(self, *, alarm_type: str) -> Iterator[GetAlarmSettingsByTypeRow]:
        result = self._conn.execute(sqlalchemy.text(GET_ALARM_SETTINGS_BY_TYPE), {"p1": alarm_type})
        for row in result:
            yield GetAlarmSettingsByTypeRow(
                guild_id=row[0],
                channel_id=row[1],
            )

    def upsert_alarm_setting(self, *, guild_id: str, alarm_type: str, channel_id: str) -> Optional[models.AlarmSetting]:
        row = self._conn.execute(sqlalchemy.text(UPSERT_ALARM_SETTING), {"p1": guild_id, "p2": alarm_type, "p3": channel_id}).first()
        if row is None:
            return None
        return models.AlarmSetting(
            guild_id=row[0],
            alarm_type=row[1],
            channel_id=row[2],
            created_at=row[3],
            updated_at=row[4],
        )


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def delete_alarm_setting(self, *, guild_id: str, alarm_type: str) -> None:
        await self._conn.execute(sqlalchemy.text(DELETE_ALARM_SETTING), {"p1": guild_id, "p2": alarm_type})

    async def delete_alarm_settings_by_channel(self, *, channel_id: str) -> None:
        await self._conn.execute(sqlalchemy.text(DELETE_ALARM_SETTINGS_BY_CHANNEL), {"p1": channel_id})

    async def get_alarm_setting(self, *, guild_id: str, alarm_type: str) -> Optional[models.AlarmSetting]:
        row = (await self._conn.execute(sqlalchemy.text(GET_ALARM_SETTING), {"p1": guild_id, "p2": alarm_type})).first()
        if row is None:
            return None
        return models.AlarmSetting(
            guild_id=row[0],
            alarm_type=row[1],
            channel_id=row[2],
            created_at=row[3],
            updated_at=row[4],
        )

    async def get_alarm_settings_by_type(self, *, alarm_type: str) -> AsyncIterator[GetAlarmSettingsByTypeRow]:
        result = await self._conn.stream(sqlalchemy.text(GET_ALARM_SETTINGS_BY_TYPE), {"p1": alarm_type})
        async for row in result:
            yield GetAlarmSettingsByTypeRow(
                guild_id=row[0],
                channel_id=row[1],
            )

    async def upsert_alarm_setting(self, *, guild_id: str, alarm_type: str, channel_id: str) -> Optional[models.AlarmSetting]:
        row = (await self._conn.execute(sqlalchemy.text(UPSERT_ALARM_SETTING), {"p1": guild_id, "p2": alarm_type, "p3": channel_id})).first()
        if row is None:
            return None
        return models.AlarmSetting(
            guild_id=row[0],
            alarm_type=row[1],
            channel_id=row[2],
            created_at=row[3],
            updated_at=row[4],
        )
